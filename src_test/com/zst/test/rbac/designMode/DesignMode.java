package com.zst.test.rbac.designMode;

/**
 * 面向对象设计原则：--封装变化
 * 				--多用组合，少用继承
 * 				--针对接口编程，不针对实现编程。
 * 				--为交互对象之间的松耦合设计而努力。
 * 				--类应该对扩展开放，对修改关闭。
 * 				--依赖倒置原则：多使用依赖抽象，尽力避免依赖具体类
 * 				--好莱坞原则：决策权在高层，通过钩子决定何时调用低层模块。高层组件调用底层组件，低层组件不直接调用高层组件，只负责实现高层需要的抽象方法
 * OO设计特性：可复用，可扩充，可维护。
 * 常把系统中变化的部分抽出来封装。
 * 大多数的模式都允许局部改变独立于其他部分。
 * @author yzj
 *
 */
public class DesignMode {

	/**
	 * 策略模式：客户决策使用哪个算法簇，（动态绑定修改算法簇）。主要是定义算法簇，分别
	 * 			封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
	 */
//---------------------------------------------------------------------------------
	/**
	 * 观察者模式：多个对象依赖于一个特定对象，当这个特定对象发生改变时，他的多个依赖对象就会收到通知并自动更新。
	 *	 主题用一个共同的接口来更新观察者。
	 *	 观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者 的细节，只知道其实现的观察者接口。
	 * 	使用此模式时，观察者可以从可观察者出拉数据，也可接受可观察者推送的数据。
	 * 	JDK实现了观察者模式 observalbe/observer。
	 * 
	 */
//---------------------------------------------------------------------------------
	/**
	 * 装饰者模式：动态的将一些功能和行为责任附加到对象上，对于功能扩展，装饰者提供了比继承更有弹性的替代方案。
	 * 注意：   1  装饰者和被装饰者实现相同的超类型。
	 * 		2 装饰者中持有被装饰者的应用变量，具体的对象在构造函数或通过Set方法或其他方式传入。
	 * 		3 多个装饰者装饰同一个对象时，确保持有的装饰者对象是同一份。
	 * 		4 装饰者类反映出被装饰的组件类型（事实上，他们有相同的类型，都经过接口或继承实现）
	 * 		5 装饰者可以在被装饰者的行为的前面或后面添加自己的装饰行为，从而达到自己的目的。
	 * 		6 装饰者会导致设计中出现许多的小对象，过度使用，程序变得复杂。
	 * 		7 一般与工厂模式和生产器模式配合使用（创建装饰者对象）。
	 * JAVA I/O使用了装饰者模式
	 */
//---------------------------------------------------------------------------------	
	/**
	 * 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是那一个，工厂方法将类的实例化推迟到子类。
	 * 注意：	1 工厂方法使用继承：吧对象的创建委托给子类，子类实现工厂方法来创建对象。
	 * 		2 依赖倒置原则：避免依赖具体类型，尽量依赖抽象。
	 * 		3 工厂帮助我们针对抽象编程，而不是针对具体类编程。
	 */
//--------------------------------------------------------------------
	/**
	 * 单例模式：确保一个类只有一个实例，并提供全局访问点。
	 * 注意：1 拥有静态变量
	 * 		2 拥有静态代码块
	 * 		3 懒加载时用同步代码块，支持多线程。而不是将同步写在方法上，这样可以提高效率（只用第一次执行的时候，才执行同步代码块）
	 */
//-----------------------------------------------------------
	/**
	 * 命令模式：将请求封装成对象，当需要将发送的请求和处理的执行请求对象进行解耦时，就用命令模式
	 * 注意：1 被解耦的两者之间通过命令对象进行沟通，命令对象封装了接收者和一组或一个动作。
	 * 		2 调用者通过调用命令对象的execute()方法发出请求，这会使得接受者的动作被执行。
	 * 		3 调用者接受命令当作参数，甚至在运行时动态进行。
	 */
//----------------------------------------------------------------
	/**
	 * 适配器模式：将一个类的接口转换成客户期望的另一个类的接口，适配器让两个不关联的类可以合作无间。
	 * 注意：1 包含要素：源接口（被适配者），目标接口（适配者），适配器
	 */
//--------------------------------------------------------------
	/**
	 * 外观模式：简化接口，提供更方便的方法。
	 */
//----------------------------------------------------
	/**
	 * 模板方法模式：在一个方法中定义一个算法骨架，而将一些步骤的实现延伸到子类中，模板算法可以使子类在不改变算法骨架的情况下，重新定义算法中的一些步骤。
	 * 注意：1 模板就是一个方法。这个方法将算法定义成一组步骤，任何步骤都可以是抽象的，由子类负责实现。
	 * 		2 模板方法可以确保算法的结构保持不变，由子类提供部分实现。
	 * 		3 模板方法是final不允许被复写。
	 * 		4 模板中加入一个共性方法：直接写一个final方法，在算法骨架中添加此方法。
	 */
//-----------------------------------------------------------------
	/**
	 * 迭代器模式：将多个对象对象的遍历操作放在一个集合Iterator中，将对象的遍历操作通过Iterator实现，而不暴露装载多个对象的实际的集合是什么。
	 * 			提供一种方法顺序访问一个聚合对象中的每一个元素，而不暴露其内部的实现。
	 * 注意：1 迭代器模式能过让我们获取到聚合元素中的每一个元素，而又不暴力器内部的实现。
	 * 		2 把遍历的任务放在迭代器上，而不是聚合上。简化了聚合的接口和实现。
	 * 		
	 */
//-------------------------------------------------------------
	/**？？？
	 * 组合模式：允许你将对象组成鼠新股来表现“整体/部分”的层次结构。组合能让客户以一致的方式处理个别对象和对象组合。
	 */
//----------------------------------------------------------
	/**
	 * 状态模式：
	 */
//--------------------------------------------------------------------
	/**
	 * 代理模式：为一个对象提供替身或占位符以控制对这个对象的访问。让代表对象控制某对象的访问。
	 * 注意：   1 代理对象可以是远程的对象，创建开销大的对象或需要安全保护的对象
	 * 		2 代理对象（proxy）持有真实对象（real）的引用。
	 * 		3 代理类和被代理类实现相同的接口。
	 * 	动态代理：
	 */
//-------------------------------------------------------------
	
}



